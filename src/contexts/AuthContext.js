import React, { createContext, useContext, useReducer, useEffect } from 'react';
import axios from '../services/axiosConfig';
import { syncWithServer } from '../utils/timeUtils';
import AuthService from '../services/AuthService';

const AuthContext = createContext();

const authReducer = (state, action) => {
  switch (action.type) {
    case 'LOGIN_START':
      return { ...state, loading: true, error: null };
    case 'LOGIN_SUCCESS':
      return {
        ...state,
        loading: false,
        isAuthenticated: true,
        user: action.payload.user,
        accessToken: action.payload.accessToken,
        error: null
      };
    case 'LOGIN_FAILURE':
      return {
        ...state,
        loading: false,
        isAuthenticated: false,
        user: null,
        accessToken: null,
        error: action.payload
      };
    case 'LOGOUT':
      return {
        ...state,
        loading: false,
        isAuthenticated: false,
        user: null,
        accessToken: null,
        error: null
      };
    case 'UPDATE_USER':
      return {
        ...state,
        user: { ...state.user, ...action.payload }
      };
    case 'CLEAR_ERROR':
      return { ...state, error: null };
    default:
      return state;
  }
};

const initialState = {
  isAuthenticated: false,
  user: null,
  accessToken: null,
  loading: true, // –ù–∞—á–∏–Ω–∞–µ–º —Å true, —á—Ç–æ–±—ã –ø–æ–∫–∞–∑–∞—Ç—å —ç–∫—Ä–∞–Ω –∑–∞–≥—Ä—É–∑–∫–∏
  error: null
};

export const AuthProvider = ({ children }) => {
  const [state, dispatch] = useReducer(authReducer, initialState);

  // Configure axios defaults
  useEffect(() => {
    console.log('üîß –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º axios interceptors...');
    
    // –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ–º –≤—Ä–µ–º—è —Å —Å–µ—Ä–≤–µ—Ä–æ–º (—Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ API –¥–æ—Å—Ç—É–ø–µ–Ω)
    try {
      syncWithServer();
      
      // –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∞—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –≤—Ä–µ–º–µ–Ω–∏ (–∫–∞–∂–¥—ã–µ 5 –º–∏–Ω—É—Ç)
      const syncInterval = setInterval(() => {
        syncWithServer().catch(error => {
          console.warn('–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –≤—Ä–µ–º–µ–Ω–∏ –Ω–µ —É–¥–∞–ª–∞—Å—å:', error);
        });
      }, 5 * 60 * 1000);
      
      return () => clearInterval(syncInterval);
    } catch (error) {
      console.warn('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞—Ç—å –≤—Ä–µ–º—è —Å —Å–µ—Ä–≤–µ—Ä–æ–º:', error);
    }
  }, []); // Remove dependencies to prevent infinite loop

  // Define updateOnlineStatus function before using it
  const updateOnlineStatus = React.useCallback(async (isOnline) => {
    console.log('üì° updateOnlineStatus –≤—ã–∑–≤–∞–Ω–∞:', isOnline, 'isAuthenticated:', state.isAuthenticated);
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —Ç–æ–∫–µ–Ω –≤ localStorage
    const token = typeof window !== 'undefined' && window.localStorage && localStorage.getItem('accessToken');
    console.log('üì° –¢–æ–∫–µ–Ω –≤ localStorage:', token ? '–µ—Å—Ç—å' : '–Ω–µ—Ç');
    if (token) {
      console.log('üì° –¢–æ–∫–µ–Ω preview:', token.substring(0, 20) + '...');
    }
    
    if (!state.isAuthenticated || !token) {
      console.log('üì° –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω –∏–ª–∏ –Ω–µ—Ç —Ç–æ–∫–µ–Ω–∞, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞');
      return;
    }
    
    try {
      console.log('üì° –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å –Ω–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞');
      console.log('üì° Axios defaults:', {
        baseURL: axios.defaults.baseURL,
        withCredentials: axios.defaults.withCredentials,
        timeout: axios.defaults.timeout
      });
      
      await axios.put('/user/status', { isOnline });
      dispatch({ type: 'UPDATE_USER', payload: { isOnline, lastSeen: new Date() } });
      console.log('üì° –°—Ç–∞—Ç—É—Å –æ–±–Ω–æ–≤–ª–µ–Ω —É—Å–ø–µ—à–Ω–æ');
    } catch (error) {
      console.error('Failed to update online status:', error);
    }
  }, [state.isAuthenticated]);

  // Handle online status based on page visibility and connection
  useEffect(() => {
    console.log('üîÑ useEffect –¥–ª—è online status, isAuthenticated:', state.isAuthenticated);
    if (!state.isAuthenticated) {
      console.log('üîÑ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫—É online status');
      return;
    }

    const handleVisibilityChange = () => {
      if (document.hidden) {
        updateOnlineStatus(false);
      } else {
        updateOnlineStatus(true);
      }
    };

    const handleBeforeUnload = () => {
      updateOnlineStatus(false);
    };

    const handleOnline = () => {
      updateOnlineStatus(true);
    };

    const handleOffline = () => {
      updateOnlineStatus(false);
    };

    // Set initial online status with delay to ensure state is updated
    setTimeout(() => {
      if (state.isAuthenticated) {
        console.log('üîÑ –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –Ω–∞—á–∞–ª—å–Ω—ã–π —Å—Ç–∞—Ç—É—Å –æ–Ω–ª–∞–π–Ω');
        updateOnlineStatus(true);
      }
    }, 100);

    // Add event listeners
    document.addEventListener('visibilitychange', handleVisibilityChange);
    window.addEventListener('beforeunload', handleBeforeUnload);
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    return () => {
      document.removeEventListener('visibilitychange', handleVisibilityChange);
      window.removeEventListener('beforeunload', handleBeforeUnload);
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
      // Set offline status when component unmounts
      updateOnlineStatus(false);
    };
  }, [state.isAuthenticated, updateOnlineStatus]);

  // Check if user is already authenticated on app load
  useEffect(() => {
    const checkAuth = async () => {
      console.log('üîç –ù–∞—á–∏–Ω–∞–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏...');
      console.log('üîç –¢–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ loading:', state.loading);
      
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º localStorage —Å—Ä–∞–∑—É
      if (typeof window !== 'undefined' && window.localStorage) {
        const allKeys = Object.keys(localStorage);
        console.log('üîç –í—Å–µ –∫–ª—é—á–∏ –≤ localStorage:', allKeys);
        const token = localStorage.getItem('accessToken');
        console.log('üîç –¢–æ–∫–µ–Ω –≤ localStorage:', token ? '–µ—Å—Ç—å' : '–Ω–µ—Ç');
        if (token) {
          console.log('üîç –¢–æ–∫–µ–Ω preview:', token.substring(0, 20) + '...');
        }
      }
      
      try {
        // Get stored access token
        const storedToken = typeof window !== 'undefined' && window.localStorage 
          ? localStorage.getItem('accessToken') 
          : null;
        console.log('üì± –¢–æ–∫–µ–Ω –≤ localStorage:', storedToken ? '–µ—Å—Ç—å' : '–Ω–µ—Ç');
        
        if (!storedToken) {
          console.log('‚ùå –ù–µ—Ç —Ç–æ–∫–µ–Ω–∞ - –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω');
          dispatch({ type: 'LOGOUT' });
          return;
        }

        console.log('‚úÖ –ï—Å—Ç—å —Ç–æ–∫–µ–Ω - –ø—Ä–æ–≤–µ—Ä—è–µ–º –µ–≥–æ –≤–∞–ª–∏–¥–Ω–æ—Å—Ç—å...');
        console.log('üîç –¢–æ–∫–µ–Ω –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏:', storedToken.substring(0, 20) + '...');
        // –ï—Å—Ç—å —Ç–æ–∫–µ–Ω - –ø—Ä–æ–≤–µ—Ä—è–µ–º –µ–≥–æ –≤–∞–ª–∏–¥–Ω–æ—Å—Ç—å
        try {
          const response = await AuthService.checkAuth();
          console.log('‚úÖ –û—Ç–≤–µ—Ç –æ—Ç checkAuth:', response.data);
          
          if (response.data.isAuthenticated && response.data.user) {
            console.log('‚úÖ –¢–æ–∫–µ–Ω –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω, –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω:', response.data.user?.email);
            dispatch({
              type: 'LOGIN_SUCCESS',
              payload: {
                user: response.data.user,
                accessToken: storedToken
              }
            });
          } else {
            console.log('‚ö†Ô∏è –¢–æ–∫–µ–Ω –Ω–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω, –ø—ã—Ç–∞–µ–º—Å—è –æ–±–Ω–æ–≤–∏—Ç—å...');
            throw new Error('Token invalid');
          }
        } catch (error) {
          console.log('‚ö†Ô∏è –¢–æ–∫–µ–Ω –Ω–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω, –ø—ã—Ç–∞–µ–º—Å—è –æ–±–Ω–æ–≤–∏—Ç—å...', error.response?.status);
          // If token is invalid, try to refresh
          try {
            const refreshResponse = await AuthService.refreshToken();
            
            const { accessToken } = refreshResponse;
            if (typeof window !== 'undefined' && window.localStorage) {
              localStorage.setItem('accessToken', accessToken);
            }
            console.log('üîÑ –¢–æ–∫–µ–Ω –æ–±–Ω–æ–≤–ª–µ–Ω, –ø–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è...');
            
            // Try to get user info again with new token
            const userResponse = await AuthService.checkAuth();
            console.log('‚úÖ –û—Ç–≤–µ—Ç –ø–æ—Å–ª–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ç–æ–∫–µ–Ω–∞:', userResponse.data);
            
            if (userResponse.data.isAuthenticated && userResponse.data.user) {
              console.log('‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω —Å –Ω–æ–≤—ã–º —Ç–æ–∫–µ–Ω–æ–º:', userResponse.data.user?.email);
              dispatch({
                type: 'LOGIN_SUCCESS',
                payload: {
                  user: userResponse.data.user,
                  accessToken
                }
              });
            } else {
              throw new Error('Still not authenticated after refresh');
            }
          } catch (refreshError) {
            console.log('‚ùå –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ç–æ–∫–µ–Ω–∞ –Ω–µ —É–¥–∞–ª–æ—Å—å, –≤—ã—Ö–æ–¥–∏–º –∏–∑ —Å–∏—Å—Ç–µ–º—ã:', refreshError.response?.status);
            if (typeof window !== 'undefined' && window.localStorage) {
              localStorage.removeItem('accessToken');
            }
            dispatch({ type: 'LOGOUT' });
          }
        }
      } catch (error) {
        console.error('üí• –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏:', error);
        // –í —Å–ª—É—á–∞–µ –ª—é–±–æ–π –æ—à–∏–±–∫–∏ - –≤—ã—Ö–æ–¥–∏–º –∏–∑ —Å–∏—Å—Ç–µ–º—ã
        if (typeof window !== 'undefined' && window.localStorage) {
          localStorage.removeItem('accessToken');
        }
        dispatch({ type: 'LOGOUT' });
      }
    };

    checkAuth();
  }, []);

  const login = async (email, password) => {
    try {
      dispatch({ type: 'LOGIN_START' });
      
      const response = await AuthService.login({
        usernameOrEmail: email,
        password
      });

      if (response.success) {
        const { user, accessToken } = response;
        
        // Store access token in localStorage
        if (accessToken && typeof window !== 'undefined' && window.localStorage) {
          localStorage.setItem('accessToken', accessToken);
        }
        
        dispatch({
          type: 'LOGIN_SUCCESS',
          payload: { user, accessToken }
        });

        return { success: true };
      } else {
        dispatch({ type: 'LOGIN_FAILURE', payload: response.error });
        return { success: false, error: response.error };
      }
    } catch (error) {
      const message = error.response?.data?.message || 'Login failed';
      dispatch({ type: 'LOGIN_FAILURE', payload: message });
      return { success: false, error: message };
    }
  };

  const register = async (userData) => {
    try {
      dispatch({ type: 'LOGIN_START' });
      
      const response = await AuthService.register(userData);

      if (response.success) {
        const { user, accessToken } = response;
        
        // Store access token in localStorage
        if (accessToken && typeof window !== 'undefined' && window.localStorage) {
          localStorage.setItem('accessToken', accessToken);
        }
        
        dispatch({
          type: 'LOGIN_SUCCESS',
          payload: { user, accessToken }
        });

        return { success: true };
      } else {
        dispatch({ type: 'LOGIN_FAILURE', payload: response.error });
        return { success: false, error: response.error };
      }
    } catch (error) {
      const message = error.response?.data?.message || 'Registration failed';
      dispatch({ type: 'LOGIN_FAILURE', payload: message });
      return { success: false, error: message };
    }
  };

  const registerProfile = async (profileData) => {
    try {
      dispatch({ type: 'LOGIN_START' });
      
      const response = await AuthService.registerProfile(profileData);

      if (response.success) {
        const { user, accessToken } = response;
        
        // Store access token in localStorage
        if (accessToken && typeof window !== 'undefined' && window.localStorage) {
          localStorage.setItem('accessToken', accessToken);
        }
        
        dispatch({
          type: 'LOGIN_SUCCESS',
          payload: { user, accessToken }
        });

        return { success: true };
      } else {
        dispatch({ type: 'LOGIN_FAILURE', payload: response.error });
        return { success: false, error: response.error };
      }
    } catch (error) {
      const message = error.response?.data?.message || 'Profile registration failed';
      dispatch({ type: 'LOGIN_FAILURE', payload: message });
      return { success: false, error: message };
    }
  };

  const logout = async () => {
    try {
      // Set offline status before logout
      await updateOnlineStatus(false);
      await AuthService.logout();
    } catch (error) {
      console.error('Logout error:', error);
    } finally {
      if (typeof window !== 'undefined' && window.localStorage) {
        localStorage.removeItem('accessToken');
      }
      dispatch({ type: 'LOGOUT' });
    }
  };

  const updateUser = (userData) => {
    dispatch({ type: 'UPDATE_USER', payload: userData });
  };

  const clearError = React.useCallback(() => {
    dispatch({ type: 'CLEAR_ERROR' });
  }, []);

  const value = {
    ...state,
    login,
    register,
    registerProfile,
    logout,
    updateUser,
    clearError,
    updateOnlineStatus
  };

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

